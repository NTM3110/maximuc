import{w as y,g as f}from"./dWGBaOqy.js";import{s as d}from"./BDygqj0r.js";const l="/rest",_="/rest/latest-value",S="/rest/network",P="maxicom-serial-ports-cache",c=y([]),p=y(!0);function I(){return{subscribe:t=>({unsubscribe:p.subscribe(t)})}}function N(){return{subscribe:(t,r)=>({unsubscribe:c.subscribe(t)})}}const i=[{id:"serial0",alias:"Port 1",devicePath:"/dev/ttyS0",channel:"dev_serial_comm_0"},{id:"serial1",alias:"Port 2",devicePath:"/dev/ttyS1",channel:"dev_serial_comm_1"},{id:"serial2",alias:"Port 3",devicePath:"/dev/ttyS2",channel:"dev_serial_comm_2"}];b(),$();function b(){try{const t=localStorage.getItem(P);if(t){const r=JSON.parse(t);c.set(r),console.log(`[Serial] Loaded ${r.length} ports from cache`)}}catch(t){console.error("[Serial] Error loading cache:",t)}}function u(t){try{localStorage.setItem(P,JSON.stringify(t))}catch(r){console.error("[Serial] Error saving cache:",r)}}async function $(){console.log("[Serial] Loading initial ports..."),p.set(!0);try{let t=await T();t.length===0&&(console.log("[Serial] Latest-value empty, fallback to channels..."),t=await A()),g(t)}catch(t){console.error("[Serial] Error loading ports:",t),g([])}}async function T(){try{const r=await(await fetch(`${_}/dev`)).json();if(!r?.success||!r.data)return[];const e=r.data,n=[];for(const o of i){const s=e[o.channel];if(typeof s=="string"&&s.trim()!==""){const a=m(o,s);a&&n.push(a)}}return n}catch(t){return console.warn("[Serial] Latest-value failed:",t),[]}}async function A(){const t=i.map(async e=>{try{const s=(await(await fetch(`${l}/channels/${e.channel}`)).json())?.record?.value;return s&&typeof s=="string"&&s.trim()!==""?m(e,s):null}catch(n){return console.error(`[Serial] Error fetching ${e.channel}:`,n),null}});return(await Promise.all(t)).filter(e=>e!==null)}function g(t){const r=f(c);let e=t;if(t.length<i.length&&r.length>0){const n=[];i.forEach(o=>{const s=t.find(a=>a.id===o.id);if(s)n.push(s);else{const a=r.find(h=>h.id===o.id);a&&n.push(a)}}),e=n}c.set(e),u(e),p.set(!1)}function m(t,r){try{const e=r.match(/^([^:]+):/),n=e?e[1]:t.devicePath,o=/:(\d+):DATABITS_(\d):([A-Z_]+):STOPBITS_([\d_]+):/,s=r.match(o);if(!s||s.length<5)return null;const a=parseInt(s[1],10),h=parseInt(s[2],10),v=s[3],E=parseFloat(s[4].replace("_","."));return{id:t.id,alias:t.alias,port:n,channel:t.channel,baudRate:a,dataBits:h,parity:v,stopBits:E}}catch(e){return console.error(`[Serial] Parse error for ${t.alias}:`,e),null}}function j(){return[...i]}async function k(t){let r;if(t.portId){if(r=i.find(s=>s.id===t.portId),!r)throw new Error("Selected port not found");const o=(await(await fetch(`${l}/channels/${r.channel}`)).json())?.record?.value;if(o&&typeof o=="string"&&o.trim()!=="")throw new Error("Port already configured")}else{for(const e of i){const s=(await(await fetch(`${l}/channels/${e.channel}`)).json())?.record?.value;if(!s||typeof s!="string"||s.trim()===""){r=e;break}}if(!r)throw new Error("Max ports reached")}return C(r,t)}async function C(t,r){const e={...r,id:t.id,alias:t.alias,port:t.devicePath,channel:t.channel};return await w(e.channel,e),c.update(n=>{const o=[...n,e].sort((s,a)=>s.alias.localeCompare(a.alias));return u(o),o}),d(`Successfully added ${e.alias}`,"success"),e}async function B(t,r){const e=f(c),n=e.findIndex(s=>s.id===t);if(n===-1)throw new Error("Port not found");const o={...e[n],...r,port:e[n].port,id:e[n].id,alias:e[n].alias,channel:e[n].channel};return await w(o.channel,o),c.update(s=>{const a=[...s];return a[n]=o,u(a),a}),d(`Successfully updated ${o.alias}`,"success"),o}async function F(t){const e=f(c).find(n=>n.id===t);if(!e)throw new Error("Port not found");await w(e.channel,null),c.update(n=>{const o=n.filter(s=>s.id!==t);return u(o),o}),d(`Successfully deleted ${e.alias}`,"success")}async function w(t,r){let e="";if(r){const s=r.stopBits.toString().replace(".","_");e=`${r.port}:RTU:SERIAL_ENCODING_RTU:${r.baudRate}:DATABITS_${r.dataBits}:${r.parity}:STOPBITS_${s}:ECHO_FALSE:FLOWCONTROL_NONE:FLOWCONTROL_NONE`}const n={record:{flag:"VALID",value:e}};if(!(await fetch(`${l}/channels/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)})).ok)throw new Error("Failed to save configuration")}async function R(){try{const t=await fetch(S);if(!t.ok)throw new Error("Failed to fetch network configs");return await t.json()}catch(t){return console.error("Error getting network configs:",t),[]}}async function x(t){const r={ipAddress:t.ipAddress,subnetMask:t.subnetMask,gateway:t.gateway,dns:t.dns,mode:t.mode},e=await fetch(`${S}/${t.id}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!e.ok)throw new Error("Failed to save network config");return d("Network saved successfully","success"),await e.json()}export{I as a,N as b,c,k as d,j as e,F as f,R as g,x as s,B as u};
